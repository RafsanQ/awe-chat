// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package db

import (
	"context"
)

const confirmFriendConnection = `-- name: ConfirmFriendConnection :exec
UPDATE friend_connections SET confirmed = true WHERE user_email_from = $1 AND user_email_to = $2
`

type ConfirmFriendConnectionParams struct {
	UserEmailFrom string `json:"user_email_from"`
	UserEmailTo   string `json:"user_email_to"`
}

func (q *Queries) ConfirmFriendConnection(ctx context.Context, arg ConfirmFriendConnectionParams) error {
	_, err := q.db.Exec(ctx, confirmFriendConnection, arg.UserEmailFrom, arg.UserEmailTo)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, username, password) VALUES ($1, $2, $3) 
RETURNING email, username, password
`

type CreateUserParams struct {
	Email    string `json:"email"`
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Username, arg.Password)
	var i User
	err := row.Scan(&i.Email, &i.Username, &i.Password)
	return i, err
}

const deleteFriendConnection = `-- name: DeleteFriendConnection :exec
DELETE FROM friend_connections WHERE user_email_from = $1 AND user_email_to = $2
`

type DeleteFriendConnectionParams struct {
	UserEmailFrom string `json:"user_email_from"`
	UserEmailTo   string `json:"user_email_to"`
}

func (q *Queries) DeleteFriendConnection(ctx context.Context, arg DeleteFriendConnectionParams) error {
	_, err := q.db.Exec(ctx, deleteFriendConnection, arg.UserEmailFrom, arg.UserEmailTo)
	return err
}

const deleteUserByEmail = `-- name: DeleteUserByEmail :exec
DELETE FROM users WHERE email = $1
`

func (q *Queries) DeleteUserByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserByEmail, email)
	return err
}

const getFriendConnections = `-- name: GetFriendConnections :many
SELECT user_email_from, user_email_to, confirmed FROM friend_connections WHERE (user_email_from = $1 AND user_email_to = $2) OR (user_email_from = $2 AND user_email_to = $1)
`

type GetFriendConnectionsParams struct {
	UserEmailFrom string `json:"user_email_from"`
	UserEmailTo   string `json:"user_email_to"`
}

func (q *Queries) GetFriendConnections(ctx context.Context, arg GetFriendConnectionsParams) ([]FriendConnection, error) {
	rows, err := q.db.Query(ctx, getFriendConnections, arg.UserEmailFrom, arg.UserEmailTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FriendConnection
	for rows.Next() {
		var i FriendConnection
		if err := rows.Scan(&i.UserEmailFrom, &i.UserEmailTo, &i.Confirmed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFriendRequests = `-- name: GetPendingFriendRequests :many
SELECT users.email, users.username FROM friend_connections JOIN users ON users.email = friend_connections.user_email_from
WHERE user_email_to = $1 AND confirmed = FALSE
`

type GetPendingFriendRequestsRow struct {
	Email    string `json:"email"`
	Username string `json:"username"`
}

func (q *Queries) GetPendingFriendRequests(ctx context.Context, userEmailTo string) ([]GetPendingFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPendingFriendRequests, userEmailTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingFriendRequestsRow
	for rows.Next() {
		var i GetPendingFriendRequestsRow
		if err := rows.Scan(&i.Email, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT email, username, password FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(&i.Email, &i.Username, &i.Password)
	return i, err
}

const requestFriendConnection = `-- name: RequestFriendConnection :exec
INSERT INTO friend_connections (user_email_from, user_email_to) VALUES ($1, $2)
`

type RequestFriendConnectionParams struct {
	UserEmailFrom string `json:"user_email_from"`
	UserEmailTo   string `json:"user_email_to"`
}

func (q *Queries) RequestFriendConnection(ctx context.Context, arg RequestFriendConnectionParams) error {
	_, err := q.db.Exec(ctx, requestFriendConnection, arg.UserEmailFrom, arg.UserEmailTo)
	return err
}

const searchUsers = `-- name: SearchUsers :many
SELECT email, username FROM users
WHERE (email ILIKE $2 OR username ILIKE $2) AND email <> $1
LIMIT 100
`

type SearchUsersParams struct {
	Email        string `json:"email"`
	SearchString string `json:"search_string"`
}

type SearchUsersRow struct {
	Email    string `json:"email"`
	Username string `json:"username"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.Email, arg.SearchString)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(&i.Email, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
